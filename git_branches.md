# Ветки в git

Основным преимуществом git в разработке чего-либо является возможность вести одновременную работу нескольким людям в одном проекте без необходимости менять рабочую версию этого самого проекта. При этом, каждый из людей может работать в своей версии, не мешая и ничего не ломая у соседей. Это добивается за счёт веток.

Ветка в git - это ответвление от основной версии ~~продукта~~ чего-нибудь, что вы разрабатываете.

Объяснил сумбурно, но, надеюсь, понятно. Давайте смотреть на деле.

## Создание новых веток

У нас есть существующий локальный репозиторий *git* на компьютере. Если не знаем, как его сделать, то смотрим [статью здесь](/GIT.md). Можно работать в старом, но у меня для написания этой статьи был сделан новый абсолютно пустой.

1) Итак, у нас есть существующий репозиторий. Создаём в нём какой-нибудь файл. ![Создан репозиторий с начальным файлом](/pictures/git_branches/git_branches_1.png)

2) Для наглядности сделаем ещё какой-нибудь коммит. Например так: ![Добавлен Люмос](/pictures/git_branches/git_branches_2.png)

3) Теперь пишем команду:

        git branch random_branch_name

    Эта команда позволит создать новую ветку с любым, нужным вам random_branch_name, в том числе и на русском языке. Например: ![создание ветки Заклинание_Левитации](/pictures/git_branches/git_branches_3.png)

4) Чтобы убедиться в том, что создана новая ветка, набираем команду:

        git branch

    Да, то же самое, но без названия новой ветки. Это важно!

    Результат должен выглядеть как-то так: ![Просмотр веток 1](/pictures/git_branches/git_branches_4.png)

    **Зелёным цветом и символом звёздочки (\*)** обозначается текущая выбранная ветка. Ниже, в моём случае текст "заклинание_левитации" - это вторая ветка. И таких веток может быть сколько угодно. сделаем ещё парочку. Реузльтат, после запроса *git branch* должен выглядеть примерно так: ![просмотр веток_2](/pictures/git_branches/git_branches_5.png)

    
## Переключение между ветками

1) Для перехода с ветки на ветку существует команда, которую мы уже использовали в предыдущей статье. Эта команда:

        git checkout random_branch_name

    Только в прошлый рз мы вводили *__master__*. Сейчас же введём название одной из тех веток, которые мы сделали. После очередного запроса *git branch* результат команды будет выглядеть примерно так:
    
    ![переключение между ветками_1](/pictures/git_branches/git_branches_6.png)

    Как видим, звёздочка и зелёный текст переместились на другую ветку. Значит, всё работает.

2) Теперь мы можем здесь написать всё что угодно, и это не затронит наш главный файл в ветке *master*. Например:

    ![текст про заклинание нокс](/pictures/git_branches/git_branches_7.png)

    Обязательно делаем сохранение и делаем новый коммит! Иначе магия *git* работать не будет.

3) Можем теперь набрать команду:

        git log

    и результат должен быть что-то вроде этого:

    ![гит_лог в ветке нокс](/pictures/git_branches/git_branches_8.png)

    Исходя из описания нашего лога коммитов, мы видим, что сейчас находимся в ветке *noks*, и она у нас рабочая. Остальные же ветки "отстали" от нас на один коммит. Если мы сейчас вернёмся в предыдущюу любую ветку, то только что набранный текст у нас пропадёт. Но при переходе опять в ветку *noks* он появиться. Можете сами это проделать через команду *git checkout random_branch_name*. Хотя и мне всё равно придётся тоже вернуться, но я вернусь в главную ветку *master*.

    ![переход в ветку master_1](/pictures/git_branches/git_branches_9.png)

## Объединение веток

1) Итак у нас на сейчас есть две версии одного файла с разными данными. Чтобы их объединить мы делаем команду:

        git merge random_branch_name

    Тут есть два очень важных момента.
    
    А) Эту команду необходимо делать оттуда, куда хотите внести изменения. То есть со стороны принимающего файла.
    

    Б) random_branch_name - это имя той ветки, откуда хотите получить изменения, то есть отправляющий файл.

    В моём случае, я из ветки *master* хочу получить данные из ветки *noks*. Поэтому изначально мы делаем преход в ветку *master*, а потом уже оттуда пишу команду *git merge noks*: Результат будет выглядеть как-то так:

    ![объеденине master и noks](/pictures/git_branches/git%20branches_10.png)

    Такой результат, можно считать, удачным стечением обстоятельств. Когда у вас новые пришлые строки попадают в ещё незанятые строки, то просто происходит объединение двух файлов. Но такое встречается крайне редко, только если это не подстроить специально.

2) Сейчас перейдём в другую ветку и напишем какие-нибудь гадости в ней на той же строке, что писали про "нокс". Например вот так в ветке *заклинание_левитации*:

    ![Вингардиум левиоса](/pictures/git_branches/git_branches_11.png)

    Обращу отдельное внимание, что новый текст написан в той же пятой строчке, что и про заклинание Нокс в предыдущей ветке. Сохраняем, коммитим и возвращаемся в ветку *master*.

3) А теперь из ветки *master* вновь делаем команду на объединение с веткой *заклинание_левитации*:

        git merge заклинание_левитации

    Результатом команды должно стать что-то вроде этого:

    ![конфликт при объединении веток](/pictures/git_branches/git_branches_12.png)

    И вот эта ситуация будет возникать чаще всего. Это называется **конфликтом**.

4) Программа VSC позволяет достаточно оперативно и наглядно решать *конфликты* при объединении нескольких веток. Так на рисунке зелёным цветом с надписью **(Current Change)** обозначено то, что было в изначальном файле. А голубым цветом с надписью **(Incoming Chang)** обозначаются пришедшие изменения. Справа внизу рабочего поля голубым цветом загорается кнопка "Решить в Мерж-редакторе". Кликнем на неё. Открывается вот такое страшное окно:

    ![мёрж-редактор](/pictures/git_branches/git_branches_13.png)

    Здесь мы уже можем построчно сравнить предлагаемые изменения и самостоятельно решить, что оставить, что убрать, а что объединить. По завершению решения нажимаем на кнопку "Завершить объединение". И после этого не забываем сохранить файл и закоммитить его.

## Удаление веток.

1) Перед тем, как мы научимся удалять ветки, вспомним о том, как их просматривать. Про команду *git branch* мы помним. Но есть ещё одна, которая отображает их более наглядно.

        git log --graph --all

    Да, именно так, с двойным тире. Результат работы этой команды будет выглядеть примерно вот так:

    ![результат команды граф-олл](/pictures/git_branches/git_branches_14.png)

    Слева от списка коммитов появляется "дерево" коммитов, которое показывает все ответвления веток от этих саммых коммитов и, самое главное, их слияние. По идее, когда ветки слиты в одну, они больше не нужны. Свою роль на изменение данных они выполнили. И, чтобы не захломлять дерево, лишние ветки нужно удалить. Да, всё как в садоводстве.

2) Для удаления ненужных ветвей используется команда

        git branch -d random_branch_name

    И, если ветка уже слита или вообще не использовалась, она будет удалена. Результат работы можно пронаблюдать в команде *git branch*. Примерно так:

    ![удаление ветки](/pictures/git_branches/git_branches_15.png)

    А вот если мы вводим команду для ветки, которую ещё не объединили, то результат будет выглядеть как-то так:

    ![удаление ветки с ошибкой](/pictures/git_branches/git_branches_16.png)

    Но это возможно только в том случае, если удаляемая ветка содержит коммит, который не объединён с какой-либо другой веткой. Если её всё же необходимо удалить, то используем вместо *-d* значение *-D*. Либо же всё-таки её объединяем.

    Если ветки нигде не использовалась, то она удалится, будто уже была объединена.

    На этом всё. Если что-то ещё вспомню, то файл обязательно дополню.

    


    Created by Ilya "Te3Ka_PaynE" Novichikhin